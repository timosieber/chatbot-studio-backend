// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ChatbotStatus {
  DRAFT
  ACTIVE
  PAUSED
  ARCHIVED
}

enum MessageRole {
  system
  user
  assistant
}

enum KnowledgeSourceType {
  URL
  TEXT
  FILE
}

enum KnowledgeSourceStatus {
  PENDING
  READY
  FAILED
}

enum IngestionJobKind {
  TEXT
  SCRAPE
  DELETE_SOURCE
}

enum IngestionJobStatus {
  PENDING
  RUNNING
  FAILED
  PARTIAL_FAILED
  SUCCEEDED
}

enum ChunkSourceType {
  WEB
  PDF
  TEXT
}

enum VectorOutboxOperation {
  UPSERT
  DELETE
}

enum VectorOutboxStatus {
  PENDING
  RUNNING
  FAILED
  SUCCEEDED
}

enum UserStatus {
  WAITLIST
  APPROVED
}

model User {
  id        String     @id @default(cuid())
  email     String     @unique
  status    UserStatus @default(WAITLIST)
  createdAt DateTime   @default(now())
  chatbots  Chatbot[]
}

model Chatbot {
  id             String               @id @default(cuid())
  userId         String
  user           User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  name           String
  description    String?
  systemPrompt   String?
  logoUrl        String?
  allowedDomains Json                 @default("[]")
  theme          Json?
  model          String               @default("gpt-4o-mini")
  status         ChatbotStatus        @default(DRAFT)
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  sessions       Session[]
  knowledgeSources KnowledgeSource[]
  ingestionJobs  IngestionJob[]

  @@index([userId])
}

model Session {
  id         String   @id @default(cuid())
  chatbotId  String
  chatbot    Chatbot  @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  origin     String
  ip         String?
  token      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  messages   Message[]

  @@index([chatbotId])
  @@index([token])
}

model Message {
  id        String      @id @default(cuid())
  sessionId String
  session   Session     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  role      MessageRole
  content   String
  createdAt DateTime    @default(now())

  @@index([sessionId])
}

model KnowledgeSource {
  id          String               @id @default(cuid())
  chatbotId   String
  chatbot     Chatbot              @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  type        KnowledgeSourceType
  label       String
  uri         String?
  canonicalUrl String?
  originalUrl  String?
  extractionMethod String?
  textQuality  String?
  status      KnowledgeSourceStatus @default(PENDING)
  metadata    Json?
  currentRevision String?
  lastIngestionJobId String?
  lastIngestedAt DateTime?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  embeddings  Embedding[]
  ingestionJobs IngestionJob[]
  chunks      KnowledgeChunk[]

  @@index([chatbotId])
}

model Embedding {
  id                String          @id @default(cuid())
  knowledgeSourceId String
  knowledgeSource   KnowledgeSource @relation(fields: [knowledgeSourceId], references: [id], onDelete: Cascade)
  vectorId          String
  content           String
  tokenCount        Int
  createdAt         DateTime        @default(now())

  @@index([knowledgeSourceId])
  @@index([vectorId])
}

model IngestionJob {
  id          String            @id @default(cuid())
  chatbotId   String
  chatbot     Chatbot           @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  knowledgeSourceId String?
  knowledgeSource KnowledgeSource? @relation(fields: [knowledgeSourceId], references: [id], onDelete: SetNull)
  kind        IngestionJobKind
  status      IngestionJobStatus @default(PENDING)
  payload     Json
  error       String?
  startedAt   DateTime?
  finishedAt  DateTime?
  totalChunks Int               @default(0)
  succeededVectors Int          @default(0)
  failedVectors Int             @default(0)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  outbox      VectorOutbox[]

  @@index([chatbotId, status, createdAt])
  @@index([knowledgeSourceId])
}

model KnowledgeChunk {
  chunkId         String          @id
  chatbotId       String
  knowledgeSourceId String
  knowledgeSource KnowledgeSource @relation(fields: [knowledgeSourceId], references: [id], onDelete: Cascade)
  createdByIngestionJobId String?
  updatedByIngestionJobId String?
  sourceType      ChunkSourceType
  uri             String?
  canonicalUrl    String?
  originalUrl     String?
  extractionMethod String?
  textQuality     String?
  phase1Anchor    Json?
  title           String
  sourceRevision  String
  pageNo          Int?
  startOffset     Int
  endOffset       Int
  canonicalText   String
  canonicalTextHash String
  embeddingModel  String
  embeddingDimensions Int
  tokenCount      Int
  deletedAt       DateTime?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([knowledgeSourceId, deletedAt])
  @@index([chatbotId, deletedAt])
  @@index([knowledgeSourceId, sourceRevision])
}

model VectorOutbox {
  id            String               @id @default(cuid())
  ingestionJobId String
  ingestionJob  IngestionJob         @relation(fields: [ingestionJobId], references: [id], onDelete: Cascade)
  chatbotId     String
  operation     VectorOutboxOperation
  chunkId       String
  status        VectorOutboxStatus    @default(PENDING)
  attemptCount  Int                  @default(0)
  lastError     String?
  nextAttemptAt DateTime             @default(now())
  processedAt   DateTime?
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  @@unique([ingestionJobId, operation, chunkId])
  @@index([status, nextAttemptAt])
  @@index([chatbotId, status])
}
